/*
tree-model-js> update version in src/TreeModel
tree-model-js> run jshint (jsh)
tree-model-js> run mocha
doc-tree-model-js> # Update the master branch
doc-tree-model-js> ./get_by_tag.sh "v0.3.0"
*/

var a = [
    {id: 1, o: 1},
    {id: 1, o: 2},
    {id: 2},
    {id: 1, o: 3},
    {id: 1, o: 5},
    {id: 1, o: 6},
    {id: 1, o: 7},
    {id: 1, o: 8},
    {id: 1, o: 9},
    {id: 1, o: 10},
    {id: 1, o: 11},
    {id: 0},
    {id: 1, o: 4}
];
var b = [
                {id: 121},
                {id: 122},
                {id: 123},
                {id: 124},
                {id: 125},
                {id: 126},
                {id: 127},
                {id: 128},
                {id: 129},
                {id: 1210},
                {id: 1211}
              ];
function s_no() {
        return 0;
}
function s_nat(a, b) {
        if (a.id === b.id) return 0;
        else return a.id < b.id ? -1 : 1;
}
function s_rev(a, b) {
        if (a.id === b.id) return 0;
        else return a.id < b.id ? 1 : -1;
}

function mergeSort_old(comparatorFn, arr) {
    var i, result = [];
    for (i = 0; i < arr.length; i++) {
        result = merge(comparatorFn, result, [arr[i]]);
    }
    return result;
}

function mergeSort(comparatorFn, arr) {
    var len = arr.length, firstHalf, secondHalf;
    if (len >= 2) {
        firstHalf = arr.slice(0, len/2);
        secondHalf = arr.slice(len/2, len);
        //console.log('firstHalf');
        //console.dir(firstHalf);
        //console.log('secondHalf');
        //console.dir(secondHalf);
        return merge(comparatorFn, mergeSort(comparatorFn, firstHalf), mergeSort(comparatorFn, secondHalf));
    } else {
        return arr;
    }
}

function merge(comparatorFn, arr1, arr2) {
    var result = [], left1 = arr1.length, left2 = arr2.length;
    while (left1 > 0 && left2 > 0) {
      if (comparatorFn(arr1[0], arr2[0]) <= 0) {
        result.push(arr1.shift());
        left1--;
      } else {
        result.push(arr2.shift());
        left2--;
      }
    }
    if (left1 > 0) {
      result.push.apply(result, arr1);
    } else {
      result.push.apply(result, arr2);
    }
    return result;
}

// For now it's linear, but can be a binary search
function findInsertIndex(comparatorFn, arr, el) {
    var i, len;
    for (i = 0, len = arr.length; i < len; i++) {
        if (comparatorFn(arr[i], el) > 0) {
            break;
        }
    }
    return i;
}

//console.log('no sort');
//console.dir(a.sort(s_no));
//console.dir(b.sort(s_no));
//console.dir(merge(s_no, [{id: 1, o: 1}, {id: 1, o: 2}, {id: 1, o: 3}, {id: 3}], [{id: 0}, {id: 1, o: 4}, {id: 2}]));
//console.dir(mergeSort(s_no, a));

console.log('natural order');
//console.dir(a.sort(s_nat));
//console.dir(b.sort(s_nat));
//console.dir(merge(s_nat, [{id: 1, o: 1}, {id: 1, o: 2}, {id: 1, o: 3}, {id: 3}], [{id: 0}, {id: 1, o: 4}, {id: 2}]));
console.dir(mergeSort(s_nat, a));
var aSortedNat = mergeSort(s_nat, a);
console.log('add {id: 1} at ' + findInsertIndex(s_nat, aSortedNat, {id: 1}));
console.log('add {id: 0} at ' + findInsertIndex(s_nat, aSortedNat, {id: 0}));
console.log('add {id: -1} at ' + findInsertIndex(s_nat, aSortedNat, {id: -1}));
console.log('add {id: 2} at ' + findInsertIndex(s_nat, aSortedNat, {id: 2}));
console.log('add {id: 3} at ' + findInsertIndex(s_nat, aSortedNat, {id: 3}));

console.log('reverse order');
//console.dir(a.sort(s_rev));
//console.dir(b.sort(s_rev));
//console.dir(merge(s_rev, [{id: 3}, {id: 1, o: 4}, {id: 1, o: 3}, {id: 1, o: 2}], [{id: 2}, {id: 1, o: 1}, {id: 0}]));
var aSortedRev = mergeSort(s_rev, a);
console.dir(mergeSort(s_rev, a));
console.log('add {id: 1} at ' + findInsertIndex(s_rev, aSortedRev, {id: 1}));
console.log('add {id: 0} at ' + findInsertIndex(s_rev, aSortedRev, {id: 0}));
console.log('add {id: -1} at ' + findInsertIndex(s_rev, aSortedRev, {id: -1}));
console.log('add {id: 2} at ' + findInsertIndex(s_rev, aSortedRev, {id: 2}));
console.log('add {id: 3} at ' + findInsertIndex(s_rev, aSortedRev, {id: 3}));